// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: moto_proto.proto

#include "moto_proto.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR ControllerInput::ControllerInput(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.leftjoysticky_)*/0
  , /*decltype(_impl_.leftjoysitckx_)*/0
  , /*decltype(_impl_.rightjoysticky_)*/0
  , /*decltype(_impl_.rightjoystickx_)*/0
  , /*decltype(_impl_.lefttrigger_)*/0
  , /*decltype(_impl_.leftbumper_)*/0
  , /*decltype(_impl_.rightbumper_)*/0
  , /*decltype(_impl_.a_)*/0
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.b_)*/0
  , /*decltype(_impl_.leftthumb_)*/0
  , /*decltype(_impl_.rightthumb_)*/0
  , /*decltype(_impl_.back_)*/0
  , /*decltype(_impl_.start_)*/0
  , /*decltype(_impl_.leftdpad_)*/0
  , /*decltype(_impl_.rightdpad_)*/0
  , /*decltype(_impl_.updpad_)*/0
  , /*decltype(_impl_.downdpad_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ControllerInputDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ControllerInputDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ControllerInputDefaultTypeInternal() {}
  union {
    ControllerInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ControllerInputDefaultTypeInternal _ControllerInput_default_instance_;
PROTOBUF_CONSTEXPR Thrusters_Pos::Thrusters_Pos(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.normx_)*/0
  , /*decltype(_impl_.normy_)*/0
  , /*decltype(_impl_.normz_)*/0
  , /*decltype(_impl_.distx_)*/0
  , /*decltype(_impl_.disty_)*/0
  , /*decltype(_impl_.distz_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Thrusters_PosDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Thrusters_PosDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Thrusters_PosDefaultTypeInternal() {}
  union {
    Thrusters_Pos _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Thrusters_PosDefaultTypeInternal _Thrusters_Pos_default_instance_;
PROTOBUF_CONSTEXPR Thrusters::Thrusters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.t1_)*/nullptr
  , /*decltype(_impl_.t2_)*/nullptr
  , /*decltype(_impl_.t3_)*/nullptr
  , /*decltype(_impl_.t4_)*/nullptr
  , /*decltype(_impl_.t5_)*/nullptr
  , /*decltype(_impl_.t6_)*/nullptr
  , /*decltype(_impl_.t7_)*/nullptr
  , /*decltype(_impl_.t8_)*/nullptr
  , /*decltype(_impl_.maxpowt1_)*/0
  , /*decltype(_impl_.maxpowt2_)*/0
  , /*decltype(_impl_.maxpowt3_)*/0
  , /*decltype(_impl_.maxpowt4_)*/0
  , /*decltype(_impl_.maxpowt5_)*/0
  , /*decltype(_impl_.maxpowt6_)*/0
  , /*decltype(_impl_.maxpowt7_)*/0
  , /*decltype(_impl_.maxpowt8_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ThrustersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThrustersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThrustersDefaultTypeInternal() {}
  union {
    Thrusters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThrustersDefaultTypeInternal _Thrusters_default_instance_;
static ::_pb::Metadata file_level_metadata_moto_5fproto_2eproto[3];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_moto_5fproto_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_moto_5fproto_2eproto = nullptr;

const uint32_t TableStruct_moto_5fproto_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ControllerInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ControllerInput, _impl_.leftjoysticky_),
  PROTOBUF_FIELD_OFFSET(::ControllerInput, _impl_.leftjoysitckx_),
  PROTOBUF_FIELD_OFFSET(::ControllerInput, _impl_.rightjoysticky_),
  PROTOBUF_FIELD_OFFSET(::ControllerInput, _impl_.rightjoystickx_),
  PROTOBUF_FIELD_OFFSET(::ControllerInput, _impl_.lefttrigger_),
  PROTOBUF_FIELD_OFFSET(::ControllerInput, _impl_.leftbumper_),
  PROTOBUF_FIELD_OFFSET(::ControllerInput, _impl_.rightbumper_),
  PROTOBUF_FIELD_OFFSET(::ControllerInput, _impl_.a_),
  PROTOBUF_FIELD_OFFSET(::ControllerInput, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::ControllerInput, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::ControllerInput, _impl_.b_),
  PROTOBUF_FIELD_OFFSET(::ControllerInput, _impl_.leftthumb_),
  PROTOBUF_FIELD_OFFSET(::ControllerInput, _impl_.rightthumb_),
  PROTOBUF_FIELD_OFFSET(::ControllerInput, _impl_.back_),
  PROTOBUF_FIELD_OFFSET(::ControllerInput, _impl_.start_),
  PROTOBUF_FIELD_OFFSET(::ControllerInput, _impl_.leftdpad_),
  PROTOBUF_FIELD_OFFSET(::ControllerInput, _impl_.rightdpad_),
  PROTOBUF_FIELD_OFFSET(::ControllerInput, _impl_.updpad_),
  PROTOBUF_FIELD_OFFSET(::ControllerInput, _impl_.downdpad_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Thrusters_Pos, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Thrusters_Pos, _impl_.normx_),
  PROTOBUF_FIELD_OFFSET(::Thrusters_Pos, _impl_.normy_),
  PROTOBUF_FIELD_OFFSET(::Thrusters_Pos, _impl_.normz_),
  PROTOBUF_FIELD_OFFSET(::Thrusters_Pos, _impl_.distx_),
  PROTOBUF_FIELD_OFFSET(::Thrusters_Pos, _impl_.disty_),
  PROTOBUF_FIELD_OFFSET(::Thrusters_Pos, _impl_.distz_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Thrusters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Thrusters, _impl_.t1_),
  PROTOBUF_FIELD_OFFSET(::Thrusters, _impl_.t2_),
  PROTOBUF_FIELD_OFFSET(::Thrusters, _impl_.t3_),
  PROTOBUF_FIELD_OFFSET(::Thrusters, _impl_.t4_),
  PROTOBUF_FIELD_OFFSET(::Thrusters, _impl_.t5_),
  PROTOBUF_FIELD_OFFSET(::Thrusters, _impl_.t6_),
  PROTOBUF_FIELD_OFFSET(::Thrusters, _impl_.t7_),
  PROTOBUF_FIELD_OFFSET(::Thrusters, _impl_.t8_),
  PROTOBUF_FIELD_OFFSET(::Thrusters, _impl_.maxpowt1_),
  PROTOBUF_FIELD_OFFSET(::Thrusters, _impl_.maxpowt2_),
  PROTOBUF_FIELD_OFFSET(::Thrusters, _impl_.maxpowt3_),
  PROTOBUF_FIELD_OFFSET(::Thrusters, _impl_.maxpowt4_),
  PROTOBUF_FIELD_OFFSET(::Thrusters, _impl_.maxpowt5_),
  PROTOBUF_FIELD_OFFSET(::Thrusters, _impl_.maxpowt6_),
  PROTOBUF_FIELD_OFFSET(::Thrusters, _impl_.maxpowt7_),
  PROTOBUF_FIELD_OFFSET(::Thrusters, _impl_.maxpowt8_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::ControllerInput)},
  { 25, -1, -1, sizeof(::Thrusters_Pos)},
  { 37, -1, -1, sizeof(::Thrusters)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_ControllerInput_default_instance_._instance,
  &::_Thrusters_Pos_default_instance_._instance,
  &::_Thrusters_default_instance_._instance,
};

const char descriptor_table_protodef_moto_5fproto_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\020moto_proto.proto\"\344\002\n\017ControllerInput\022\025"
  "\n\rLeftJoystickY\030\001 \001(\002\022\025\n\rLeftJoysitckX\030\002"
  " \001(\002\022\026\n\016RightJoystickY\030\003 \001(\002\022\026\n\016RightJoy"
  "stickX\030\004 \001(\002\022\023\n\013LeftTrigger\030\005 \001(\002\022\022\n\nLef"
  "tBumper\030\006 \001(\002\022\023\n\013RightBumper\030\007 \001(\002\022\t\n\001A\030"
  "\010 \001(\002\022\t\n\001X\030\t \001(\002\022\t\n\001Y\030\n \001(\002\022\t\n\001B\030\013 \001(\002\022\021"
  "\n\tLeftThumb\030\014 \001(\002\022\022\n\nRightThumb\030\r \001(\002\022\014\n"
  "\004Back\030\016 \001(\002\022\r\n\005Start\030\017 \001(\002\022\020\n\010LeftDPad\030\020"
  " \001(\002\022\021\n\tRightDPad\030\021 \001(\002\022\016\n\006UpDPad\030\022 \001(\002\022"
  "\020\n\010DownDPad\030\023 \001(\002\"\334\003\n\tThrusters\022\032\n\002T1\030\001 "
  "\001(\0132\016.Thrusters.Pos\022\032\n\002T2\030\002 \001(\0132\016.Thrust"
  "ers.Pos\022\032\n\002T3\030\003 \001(\0132\016.Thrusters.Pos\022\032\n\002T"
  "4\030\004 \001(\0132\016.Thrusters.Pos\022\032\n\002T5\030\005 \001(\0132\016.Th"
  "rusters.Pos\022\032\n\002T6\030\006 \001(\0132\016.Thrusters.Pos\022"
  "\032\n\002T7\030\007 \001(\0132\016.Thrusters.Pos\022\032\n\002T8\030\010 \001(\0132"
  "\016.Thrusters.Pos\022\020\n\010MaxPowT1\030\t \001(\002\022\020\n\010Max"
  "PowT2\030\n \001(\002\022\020\n\010MaxPowT3\030\013 \001(\002\022\020\n\010MaxPowT"
  "4\030\014 \001(\002\022\020\n\010MaxPowT5\030\r \001(\002\022\020\n\010MaxPowT6\030\016 "
  "\001(\002\022\020\n\010MaxPowT7\030\017 \001(\002\022\020\n\010MaxPowT8\030\020 \001(\002\032"
  "_\n\003Pos\022\r\n\005normX\030\001 \001(\002\022\r\n\005normY\030\002 \001(\002\022\r\n\005"
  "normZ\030\003 \001(\002\022\r\n\005distX\030\004 \001(\002\022\r\n\005distY\030\005 \001("
  "\002\022\r\n\005distZ\030\006 \001(\002b\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_moto_5fproto_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_moto_5fproto_2eproto = {
    false, false, 864, descriptor_table_protodef_moto_5fproto_2eproto,
    "moto_proto.proto",
    &descriptor_table_moto_5fproto_2eproto_once, nullptr, 0, 3,
    schemas, file_default_instances, TableStruct_moto_5fproto_2eproto::offsets,
    file_level_metadata_moto_5fproto_2eproto, file_level_enum_descriptors_moto_5fproto_2eproto,
    file_level_service_descriptors_moto_5fproto_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_moto_5fproto_2eproto_getter() {
  return &descriptor_table_moto_5fproto_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_moto_5fproto_2eproto(&descriptor_table_moto_5fproto_2eproto);

// ===================================================================

class ControllerInput::_Internal {
 public:
};

ControllerInput::ControllerInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ControllerInput)
}
ControllerInput::ControllerInput(const ControllerInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ControllerInput* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.leftjoysticky_){}
    , decltype(_impl_.leftjoysitckx_){}
    , decltype(_impl_.rightjoysticky_){}
    , decltype(_impl_.rightjoystickx_){}
    , decltype(_impl_.lefttrigger_){}
    , decltype(_impl_.leftbumper_){}
    , decltype(_impl_.rightbumper_){}
    , decltype(_impl_.a_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.b_){}
    , decltype(_impl_.leftthumb_){}
    , decltype(_impl_.rightthumb_){}
    , decltype(_impl_.back_){}
    , decltype(_impl_.start_){}
    , decltype(_impl_.leftdpad_){}
    , decltype(_impl_.rightdpad_){}
    , decltype(_impl_.updpad_){}
    , decltype(_impl_.downdpad_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.leftjoysticky_, &from._impl_.leftjoysticky_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.downdpad_) -
    reinterpret_cast<char*>(&_impl_.leftjoysticky_)) + sizeof(_impl_.downdpad_));
  // @@protoc_insertion_point(copy_constructor:ControllerInput)
}

inline void ControllerInput::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.leftjoysticky_){0}
    , decltype(_impl_.leftjoysitckx_){0}
    , decltype(_impl_.rightjoysticky_){0}
    , decltype(_impl_.rightjoystickx_){0}
    , decltype(_impl_.lefttrigger_){0}
    , decltype(_impl_.leftbumper_){0}
    , decltype(_impl_.rightbumper_){0}
    , decltype(_impl_.a_){0}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.b_){0}
    , decltype(_impl_.leftthumb_){0}
    , decltype(_impl_.rightthumb_){0}
    , decltype(_impl_.back_){0}
    , decltype(_impl_.start_){0}
    , decltype(_impl_.leftdpad_){0}
    , decltype(_impl_.rightdpad_){0}
    , decltype(_impl_.updpad_){0}
    , decltype(_impl_.downdpad_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ControllerInput::~ControllerInput() {
  // @@protoc_insertion_point(destructor:ControllerInput)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ControllerInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ControllerInput::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ControllerInput::Clear() {
// @@protoc_insertion_point(message_clear_start:ControllerInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.leftjoysticky_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.downdpad_) -
      reinterpret_cast<char*>(&_impl_.leftjoysticky_)) + sizeof(_impl_.downdpad_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ControllerInput::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float LeftJoystickY = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.leftjoysticky_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float LeftJoysitckX = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.leftjoysitckx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float RightJoystickY = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.rightjoysticky_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float RightJoystickX = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.rightjoystickx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float LeftTrigger = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _impl_.lefttrigger_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float LeftBumper = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _impl_.leftbumper_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float RightBumper = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _impl_.rightbumper_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float A = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _impl_.a_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float X = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float Y = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float B = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _impl_.b_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float LeftThumb = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _impl_.leftthumb_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float RightThumb = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _impl_.rightthumb_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float Back = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          _impl_.back_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float Start = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          _impl_.start_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float LeftDPad = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 133)) {
          _impl_.leftdpad_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float RightDPad = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 141)) {
          _impl_.rightdpad_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float UpDPad = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 149)) {
          _impl_.updpad_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float DownDPad = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 157)) {
          _impl_.downdpad_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ControllerInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ControllerInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float LeftJoystickY = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_leftjoysticky = this->_internal_leftjoysticky();
  uint32_t raw_leftjoysticky;
  memcpy(&raw_leftjoysticky, &tmp_leftjoysticky, sizeof(tmp_leftjoysticky));
  if (raw_leftjoysticky != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_leftjoysticky(), target);
  }

  // float LeftJoysitckX = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_leftjoysitckx = this->_internal_leftjoysitckx();
  uint32_t raw_leftjoysitckx;
  memcpy(&raw_leftjoysitckx, &tmp_leftjoysitckx, sizeof(tmp_leftjoysitckx));
  if (raw_leftjoysitckx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_leftjoysitckx(), target);
  }

  // float RightJoystickY = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rightjoysticky = this->_internal_rightjoysticky();
  uint32_t raw_rightjoysticky;
  memcpy(&raw_rightjoysticky, &tmp_rightjoysticky, sizeof(tmp_rightjoysticky));
  if (raw_rightjoysticky != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_rightjoysticky(), target);
  }

  // float RightJoystickX = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rightjoystickx = this->_internal_rightjoystickx();
  uint32_t raw_rightjoystickx;
  memcpy(&raw_rightjoystickx, &tmp_rightjoystickx, sizeof(tmp_rightjoystickx));
  if (raw_rightjoystickx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_rightjoystickx(), target);
  }

  // float LeftTrigger = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lefttrigger = this->_internal_lefttrigger();
  uint32_t raw_lefttrigger;
  memcpy(&raw_lefttrigger, &tmp_lefttrigger, sizeof(tmp_lefttrigger));
  if (raw_lefttrigger != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_lefttrigger(), target);
  }

  // float LeftBumper = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_leftbumper = this->_internal_leftbumper();
  uint32_t raw_leftbumper;
  memcpy(&raw_leftbumper, &tmp_leftbumper, sizeof(tmp_leftbumper));
  if (raw_leftbumper != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_leftbumper(), target);
  }

  // float RightBumper = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rightbumper = this->_internal_rightbumper();
  uint32_t raw_rightbumper;
  memcpy(&raw_rightbumper, &tmp_rightbumper, sizeof(tmp_rightbumper));
  if (raw_rightbumper != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_rightbumper(), target);
  }

  // float A = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_a = this->_internal_a();
  uint32_t raw_a;
  memcpy(&raw_a, &tmp_a, sizeof(tmp_a));
  if (raw_a != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_a(), target);
  }

  // float X = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_x(), target);
  }

  // float Y = 10;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_y(), target);
  }

  // float B = 11;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_b = this->_internal_b();
  uint32_t raw_b;
  memcpy(&raw_b, &tmp_b, sizeof(tmp_b));
  if (raw_b != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_b(), target);
  }

  // float LeftThumb = 12;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_leftthumb = this->_internal_leftthumb();
  uint32_t raw_leftthumb;
  memcpy(&raw_leftthumb, &tmp_leftthumb, sizeof(tmp_leftthumb));
  if (raw_leftthumb != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(12, this->_internal_leftthumb(), target);
  }

  // float RightThumb = 13;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rightthumb = this->_internal_rightthumb();
  uint32_t raw_rightthumb;
  memcpy(&raw_rightthumb, &tmp_rightthumb, sizeof(tmp_rightthumb));
  if (raw_rightthumb != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(13, this->_internal_rightthumb(), target);
  }

  // float Back = 14;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_back = this->_internal_back();
  uint32_t raw_back;
  memcpy(&raw_back, &tmp_back, sizeof(tmp_back));
  if (raw_back != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(14, this->_internal_back(), target);
  }

  // float Start = 15;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_start = this->_internal_start();
  uint32_t raw_start;
  memcpy(&raw_start, &tmp_start, sizeof(tmp_start));
  if (raw_start != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(15, this->_internal_start(), target);
  }

  // float LeftDPad = 16;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_leftdpad = this->_internal_leftdpad();
  uint32_t raw_leftdpad;
  memcpy(&raw_leftdpad, &tmp_leftdpad, sizeof(tmp_leftdpad));
  if (raw_leftdpad != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(16, this->_internal_leftdpad(), target);
  }

  // float RightDPad = 17;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rightdpad = this->_internal_rightdpad();
  uint32_t raw_rightdpad;
  memcpy(&raw_rightdpad, &tmp_rightdpad, sizeof(tmp_rightdpad));
  if (raw_rightdpad != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(17, this->_internal_rightdpad(), target);
  }

  // float UpDPad = 18;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_updpad = this->_internal_updpad();
  uint32_t raw_updpad;
  memcpy(&raw_updpad, &tmp_updpad, sizeof(tmp_updpad));
  if (raw_updpad != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(18, this->_internal_updpad(), target);
  }

  // float DownDPad = 19;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_downdpad = this->_internal_downdpad();
  uint32_t raw_downdpad;
  memcpy(&raw_downdpad, &tmp_downdpad, sizeof(tmp_downdpad));
  if (raw_downdpad != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(19, this->_internal_downdpad(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ControllerInput)
  return target;
}

size_t ControllerInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ControllerInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float LeftJoystickY = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_leftjoysticky = this->_internal_leftjoysticky();
  uint32_t raw_leftjoysticky;
  memcpy(&raw_leftjoysticky, &tmp_leftjoysticky, sizeof(tmp_leftjoysticky));
  if (raw_leftjoysticky != 0) {
    total_size += 1 + 4;
  }

  // float LeftJoysitckX = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_leftjoysitckx = this->_internal_leftjoysitckx();
  uint32_t raw_leftjoysitckx;
  memcpy(&raw_leftjoysitckx, &tmp_leftjoysitckx, sizeof(tmp_leftjoysitckx));
  if (raw_leftjoysitckx != 0) {
    total_size += 1 + 4;
  }

  // float RightJoystickY = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rightjoysticky = this->_internal_rightjoysticky();
  uint32_t raw_rightjoysticky;
  memcpy(&raw_rightjoysticky, &tmp_rightjoysticky, sizeof(tmp_rightjoysticky));
  if (raw_rightjoysticky != 0) {
    total_size += 1 + 4;
  }

  // float RightJoystickX = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rightjoystickx = this->_internal_rightjoystickx();
  uint32_t raw_rightjoystickx;
  memcpy(&raw_rightjoystickx, &tmp_rightjoystickx, sizeof(tmp_rightjoystickx));
  if (raw_rightjoystickx != 0) {
    total_size += 1 + 4;
  }

  // float LeftTrigger = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lefttrigger = this->_internal_lefttrigger();
  uint32_t raw_lefttrigger;
  memcpy(&raw_lefttrigger, &tmp_lefttrigger, sizeof(tmp_lefttrigger));
  if (raw_lefttrigger != 0) {
    total_size += 1 + 4;
  }

  // float LeftBumper = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_leftbumper = this->_internal_leftbumper();
  uint32_t raw_leftbumper;
  memcpy(&raw_leftbumper, &tmp_leftbumper, sizeof(tmp_leftbumper));
  if (raw_leftbumper != 0) {
    total_size += 1 + 4;
  }

  // float RightBumper = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rightbumper = this->_internal_rightbumper();
  uint32_t raw_rightbumper;
  memcpy(&raw_rightbumper, &tmp_rightbumper, sizeof(tmp_rightbumper));
  if (raw_rightbumper != 0) {
    total_size += 1 + 4;
  }

  // float A = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_a = this->_internal_a();
  uint32_t raw_a;
  memcpy(&raw_a, &tmp_a, sizeof(tmp_a));
  if (raw_a != 0) {
    total_size += 1 + 4;
  }

  // float X = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float Y = 10;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  // float B = 11;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_b = this->_internal_b();
  uint32_t raw_b;
  memcpy(&raw_b, &tmp_b, sizeof(tmp_b));
  if (raw_b != 0) {
    total_size += 1 + 4;
  }

  // float LeftThumb = 12;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_leftthumb = this->_internal_leftthumb();
  uint32_t raw_leftthumb;
  memcpy(&raw_leftthumb, &tmp_leftthumb, sizeof(tmp_leftthumb));
  if (raw_leftthumb != 0) {
    total_size += 1 + 4;
  }

  // float RightThumb = 13;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rightthumb = this->_internal_rightthumb();
  uint32_t raw_rightthumb;
  memcpy(&raw_rightthumb, &tmp_rightthumb, sizeof(tmp_rightthumb));
  if (raw_rightthumb != 0) {
    total_size += 1 + 4;
  }

  // float Back = 14;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_back = this->_internal_back();
  uint32_t raw_back;
  memcpy(&raw_back, &tmp_back, sizeof(tmp_back));
  if (raw_back != 0) {
    total_size += 1 + 4;
  }

  // float Start = 15;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_start = this->_internal_start();
  uint32_t raw_start;
  memcpy(&raw_start, &tmp_start, sizeof(tmp_start));
  if (raw_start != 0) {
    total_size += 1 + 4;
  }

  // float LeftDPad = 16;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_leftdpad = this->_internal_leftdpad();
  uint32_t raw_leftdpad;
  memcpy(&raw_leftdpad, &tmp_leftdpad, sizeof(tmp_leftdpad));
  if (raw_leftdpad != 0) {
    total_size += 2 + 4;
  }

  // float RightDPad = 17;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rightdpad = this->_internal_rightdpad();
  uint32_t raw_rightdpad;
  memcpy(&raw_rightdpad, &tmp_rightdpad, sizeof(tmp_rightdpad));
  if (raw_rightdpad != 0) {
    total_size += 2 + 4;
  }

  // float UpDPad = 18;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_updpad = this->_internal_updpad();
  uint32_t raw_updpad;
  memcpy(&raw_updpad, &tmp_updpad, sizeof(tmp_updpad));
  if (raw_updpad != 0) {
    total_size += 2 + 4;
  }

  // float DownDPad = 19;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_downdpad = this->_internal_downdpad();
  uint32_t raw_downdpad;
  memcpy(&raw_downdpad, &tmp_downdpad, sizeof(tmp_downdpad));
  if (raw_downdpad != 0) {
    total_size += 2 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ControllerInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ControllerInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ControllerInput::GetClassData() const { return &_class_data_; }


void ControllerInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ControllerInput*>(&to_msg);
  auto& from = static_cast<const ControllerInput&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ControllerInput)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_leftjoysticky = from._internal_leftjoysticky();
  uint32_t raw_leftjoysticky;
  memcpy(&raw_leftjoysticky, &tmp_leftjoysticky, sizeof(tmp_leftjoysticky));
  if (raw_leftjoysticky != 0) {
    _this->_internal_set_leftjoysticky(from._internal_leftjoysticky());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_leftjoysitckx = from._internal_leftjoysitckx();
  uint32_t raw_leftjoysitckx;
  memcpy(&raw_leftjoysitckx, &tmp_leftjoysitckx, sizeof(tmp_leftjoysitckx));
  if (raw_leftjoysitckx != 0) {
    _this->_internal_set_leftjoysitckx(from._internal_leftjoysitckx());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rightjoysticky = from._internal_rightjoysticky();
  uint32_t raw_rightjoysticky;
  memcpy(&raw_rightjoysticky, &tmp_rightjoysticky, sizeof(tmp_rightjoysticky));
  if (raw_rightjoysticky != 0) {
    _this->_internal_set_rightjoysticky(from._internal_rightjoysticky());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rightjoystickx = from._internal_rightjoystickx();
  uint32_t raw_rightjoystickx;
  memcpy(&raw_rightjoystickx, &tmp_rightjoystickx, sizeof(tmp_rightjoystickx));
  if (raw_rightjoystickx != 0) {
    _this->_internal_set_rightjoystickx(from._internal_rightjoystickx());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lefttrigger = from._internal_lefttrigger();
  uint32_t raw_lefttrigger;
  memcpy(&raw_lefttrigger, &tmp_lefttrigger, sizeof(tmp_lefttrigger));
  if (raw_lefttrigger != 0) {
    _this->_internal_set_lefttrigger(from._internal_lefttrigger());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_leftbumper = from._internal_leftbumper();
  uint32_t raw_leftbumper;
  memcpy(&raw_leftbumper, &tmp_leftbumper, sizeof(tmp_leftbumper));
  if (raw_leftbumper != 0) {
    _this->_internal_set_leftbumper(from._internal_leftbumper());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rightbumper = from._internal_rightbumper();
  uint32_t raw_rightbumper;
  memcpy(&raw_rightbumper, &tmp_rightbumper, sizeof(tmp_rightbumper));
  if (raw_rightbumper != 0) {
    _this->_internal_set_rightbumper(from._internal_rightbumper());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_a = from._internal_a();
  uint32_t raw_a;
  memcpy(&raw_a, &tmp_a, sizeof(tmp_a));
  if (raw_a != 0) {
    _this->_internal_set_a(from._internal_a());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_b = from._internal_b();
  uint32_t raw_b;
  memcpy(&raw_b, &tmp_b, sizeof(tmp_b));
  if (raw_b != 0) {
    _this->_internal_set_b(from._internal_b());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_leftthumb = from._internal_leftthumb();
  uint32_t raw_leftthumb;
  memcpy(&raw_leftthumb, &tmp_leftthumb, sizeof(tmp_leftthumb));
  if (raw_leftthumb != 0) {
    _this->_internal_set_leftthumb(from._internal_leftthumb());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rightthumb = from._internal_rightthumb();
  uint32_t raw_rightthumb;
  memcpy(&raw_rightthumb, &tmp_rightthumb, sizeof(tmp_rightthumb));
  if (raw_rightthumb != 0) {
    _this->_internal_set_rightthumb(from._internal_rightthumb());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_back = from._internal_back();
  uint32_t raw_back;
  memcpy(&raw_back, &tmp_back, sizeof(tmp_back));
  if (raw_back != 0) {
    _this->_internal_set_back(from._internal_back());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_start = from._internal_start();
  uint32_t raw_start;
  memcpy(&raw_start, &tmp_start, sizeof(tmp_start));
  if (raw_start != 0) {
    _this->_internal_set_start(from._internal_start());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_leftdpad = from._internal_leftdpad();
  uint32_t raw_leftdpad;
  memcpy(&raw_leftdpad, &tmp_leftdpad, sizeof(tmp_leftdpad));
  if (raw_leftdpad != 0) {
    _this->_internal_set_leftdpad(from._internal_leftdpad());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rightdpad = from._internal_rightdpad();
  uint32_t raw_rightdpad;
  memcpy(&raw_rightdpad, &tmp_rightdpad, sizeof(tmp_rightdpad));
  if (raw_rightdpad != 0) {
    _this->_internal_set_rightdpad(from._internal_rightdpad());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_updpad = from._internal_updpad();
  uint32_t raw_updpad;
  memcpy(&raw_updpad, &tmp_updpad, sizeof(tmp_updpad));
  if (raw_updpad != 0) {
    _this->_internal_set_updpad(from._internal_updpad());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_downdpad = from._internal_downdpad();
  uint32_t raw_downdpad;
  memcpy(&raw_downdpad, &tmp_downdpad, sizeof(tmp_downdpad));
  if (raw_downdpad != 0) {
    _this->_internal_set_downdpad(from._internal_downdpad());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ControllerInput::CopyFrom(const ControllerInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ControllerInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ControllerInput::IsInitialized() const {
  return true;
}

void ControllerInput::InternalSwap(ControllerInput* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ControllerInput, _impl_.downdpad_)
      + sizeof(ControllerInput::_impl_.downdpad_)
      - PROTOBUF_FIELD_OFFSET(ControllerInput, _impl_.leftjoysticky_)>(
          reinterpret_cast<char*>(&_impl_.leftjoysticky_),
          reinterpret_cast<char*>(&other->_impl_.leftjoysticky_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ControllerInput::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_moto_5fproto_2eproto_getter, &descriptor_table_moto_5fproto_2eproto_once,
      file_level_metadata_moto_5fproto_2eproto[0]);
}

// ===================================================================

class Thrusters_Pos::_Internal {
 public:
};

Thrusters_Pos::Thrusters_Pos(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Thrusters.Pos)
}
Thrusters_Pos::Thrusters_Pos(const Thrusters_Pos& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Thrusters_Pos* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.normx_){}
    , decltype(_impl_.normy_){}
    , decltype(_impl_.normz_){}
    , decltype(_impl_.distx_){}
    , decltype(_impl_.disty_){}
    , decltype(_impl_.distz_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.normx_, &from._impl_.normx_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.distz_) -
    reinterpret_cast<char*>(&_impl_.normx_)) + sizeof(_impl_.distz_));
  // @@protoc_insertion_point(copy_constructor:Thrusters.Pos)
}

inline void Thrusters_Pos::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.normx_){0}
    , decltype(_impl_.normy_){0}
    , decltype(_impl_.normz_){0}
    , decltype(_impl_.distx_){0}
    , decltype(_impl_.disty_){0}
    , decltype(_impl_.distz_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Thrusters_Pos::~Thrusters_Pos() {
  // @@protoc_insertion_point(destructor:Thrusters.Pos)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Thrusters_Pos::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Thrusters_Pos::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Thrusters_Pos::Clear() {
// @@protoc_insertion_point(message_clear_start:Thrusters.Pos)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.normx_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.distz_) -
      reinterpret_cast<char*>(&_impl_.normx_)) + sizeof(_impl_.distz_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Thrusters_Pos::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float normX = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.normx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float normY = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.normy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float normZ = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.normz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float distX = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.distx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float distY = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _impl_.disty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float distZ = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _impl_.distz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Thrusters_Pos::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Thrusters.Pos)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float normX = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_normx = this->_internal_normx();
  uint32_t raw_normx;
  memcpy(&raw_normx, &tmp_normx, sizeof(tmp_normx));
  if (raw_normx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_normx(), target);
  }

  // float normY = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_normy = this->_internal_normy();
  uint32_t raw_normy;
  memcpy(&raw_normy, &tmp_normy, sizeof(tmp_normy));
  if (raw_normy != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_normy(), target);
  }

  // float normZ = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_normz = this->_internal_normz();
  uint32_t raw_normz;
  memcpy(&raw_normz, &tmp_normz, sizeof(tmp_normz));
  if (raw_normz != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_normz(), target);
  }

  // float distX = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_distx = this->_internal_distx();
  uint32_t raw_distx;
  memcpy(&raw_distx, &tmp_distx, sizeof(tmp_distx));
  if (raw_distx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_distx(), target);
  }

  // float distY = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_disty = this->_internal_disty();
  uint32_t raw_disty;
  memcpy(&raw_disty, &tmp_disty, sizeof(tmp_disty));
  if (raw_disty != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_disty(), target);
  }

  // float distZ = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_distz = this->_internal_distz();
  uint32_t raw_distz;
  memcpy(&raw_distz, &tmp_distz, sizeof(tmp_distz));
  if (raw_distz != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_distz(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Thrusters.Pos)
  return target;
}

size_t Thrusters_Pos::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Thrusters.Pos)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float normX = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_normx = this->_internal_normx();
  uint32_t raw_normx;
  memcpy(&raw_normx, &tmp_normx, sizeof(tmp_normx));
  if (raw_normx != 0) {
    total_size += 1 + 4;
  }

  // float normY = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_normy = this->_internal_normy();
  uint32_t raw_normy;
  memcpy(&raw_normy, &tmp_normy, sizeof(tmp_normy));
  if (raw_normy != 0) {
    total_size += 1 + 4;
  }

  // float normZ = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_normz = this->_internal_normz();
  uint32_t raw_normz;
  memcpy(&raw_normz, &tmp_normz, sizeof(tmp_normz));
  if (raw_normz != 0) {
    total_size += 1 + 4;
  }

  // float distX = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_distx = this->_internal_distx();
  uint32_t raw_distx;
  memcpy(&raw_distx, &tmp_distx, sizeof(tmp_distx));
  if (raw_distx != 0) {
    total_size += 1 + 4;
  }

  // float distY = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_disty = this->_internal_disty();
  uint32_t raw_disty;
  memcpy(&raw_disty, &tmp_disty, sizeof(tmp_disty));
  if (raw_disty != 0) {
    total_size += 1 + 4;
  }

  // float distZ = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_distz = this->_internal_distz();
  uint32_t raw_distz;
  memcpy(&raw_distz, &tmp_distz, sizeof(tmp_distz));
  if (raw_distz != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Thrusters_Pos::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Thrusters_Pos::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Thrusters_Pos::GetClassData() const { return &_class_data_; }


void Thrusters_Pos::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Thrusters_Pos*>(&to_msg);
  auto& from = static_cast<const Thrusters_Pos&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Thrusters.Pos)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_normx = from._internal_normx();
  uint32_t raw_normx;
  memcpy(&raw_normx, &tmp_normx, sizeof(tmp_normx));
  if (raw_normx != 0) {
    _this->_internal_set_normx(from._internal_normx());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_normy = from._internal_normy();
  uint32_t raw_normy;
  memcpy(&raw_normy, &tmp_normy, sizeof(tmp_normy));
  if (raw_normy != 0) {
    _this->_internal_set_normy(from._internal_normy());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_normz = from._internal_normz();
  uint32_t raw_normz;
  memcpy(&raw_normz, &tmp_normz, sizeof(tmp_normz));
  if (raw_normz != 0) {
    _this->_internal_set_normz(from._internal_normz());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_distx = from._internal_distx();
  uint32_t raw_distx;
  memcpy(&raw_distx, &tmp_distx, sizeof(tmp_distx));
  if (raw_distx != 0) {
    _this->_internal_set_distx(from._internal_distx());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_disty = from._internal_disty();
  uint32_t raw_disty;
  memcpy(&raw_disty, &tmp_disty, sizeof(tmp_disty));
  if (raw_disty != 0) {
    _this->_internal_set_disty(from._internal_disty());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_distz = from._internal_distz();
  uint32_t raw_distz;
  memcpy(&raw_distz, &tmp_distz, sizeof(tmp_distz));
  if (raw_distz != 0) {
    _this->_internal_set_distz(from._internal_distz());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Thrusters_Pos::CopyFrom(const Thrusters_Pos& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Thrusters.Pos)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Thrusters_Pos::IsInitialized() const {
  return true;
}

void Thrusters_Pos::InternalSwap(Thrusters_Pos* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Thrusters_Pos, _impl_.distz_)
      + sizeof(Thrusters_Pos::_impl_.distz_)
      - PROTOBUF_FIELD_OFFSET(Thrusters_Pos, _impl_.normx_)>(
          reinterpret_cast<char*>(&_impl_.normx_),
          reinterpret_cast<char*>(&other->_impl_.normx_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Thrusters_Pos::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_moto_5fproto_2eproto_getter, &descriptor_table_moto_5fproto_2eproto_once,
      file_level_metadata_moto_5fproto_2eproto[1]);
}

// ===================================================================

class Thrusters::_Internal {
 public:
  static const ::Thrusters_Pos& t1(const Thrusters* msg);
  static const ::Thrusters_Pos& t2(const Thrusters* msg);
  static const ::Thrusters_Pos& t3(const Thrusters* msg);
  static const ::Thrusters_Pos& t4(const Thrusters* msg);
  static const ::Thrusters_Pos& t5(const Thrusters* msg);
  static const ::Thrusters_Pos& t6(const Thrusters* msg);
  static const ::Thrusters_Pos& t7(const Thrusters* msg);
  static const ::Thrusters_Pos& t8(const Thrusters* msg);
};

const ::Thrusters_Pos&
Thrusters::_Internal::t1(const Thrusters* msg) {
  return *msg->_impl_.t1_;
}
const ::Thrusters_Pos&
Thrusters::_Internal::t2(const Thrusters* msg) {
  return *msg->_impl_.t2_;
}
const ::Thrusters_Pos&
Thrusters::_Internal::t3(const Thrusters* msg) {
  return *msg->_impl_.t3_;
}
const ::Thrusters_Pos&
Thrusters::_Internal::t4(const Thrusters* msg) {
  return *msg->_impl_.t4_;
}
const ::Thrusters_Pos&
Thrusters::_Internal::t5(const Thrusters* msg) {
  return *msg->_impl_.t5_;
}
const ::Thrusters_Pos&
Thrusters::_Internal::t6(const Thrusters* msg) {
  return *msg->_impl_.t6_;
}
const ::Thrusters_Pos&
Thrusters::_Internal::t7(const Thrusters* msg) {
  return *msg->_impl_.t7_;
}
const ::Thrusters_Pos&
Thrusters::_Internal::t8(const Thrusters* msg) {
  return *msg->_impl_.t8_;
}
Thrusters::Thrusters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Thrusters)
}
Thrusters::Thrusters(const Thrusters& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Thrusters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.t1_){nullptr}
    , decltype(_impl_.t2_){nullptr}
    , decltype(_impl_.t3_){nullptr}
    , decltype(_impl_.t4_){nullptr}
    , decltype(_impl_.t5_){nullptr}
    , decltype(_impl_.t6_){nullptr}
    , decltype(_impl_.t7_){nullptr}
    , decltype(_impl_.t8_){nullptr}
    , decltype(_impl_.maxpowt1_){}
    , decltype(_impl_.maxpowt2_){}
    , decltype(_impl_.maxpowt3_){}
    , decltype(_impl_.maxpowt4_){}
    , decltype(_impl_.maxpowt5_){}
    , decltype(_impl_.maxpowt6_){}
    , decltype(_impl_.maxpowt7_){}
    , decltype(_impl_.maxpowt8_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_t1()) {
    _this->_impl_.t1_ = new ::Thrusters_Pos(*from._impl_.t1_);
  }
  if (from._internal_has_t2()) {
    _this->_impl_.t2_ = new ::Thrusters_Pos(*from._impl_.t2_);
  }
  if (from._internal_has_t3()) {
    _this->_impl_.t3_ = new ::Thrusters_Pos(*from._impl_.t3_);
  }
  if (from._internal_has_t4()) {
    _this->_impl_.t4_ = new ::Thrusters_Pos(*from._impl_.t4_);
  }
  if (from._internal_has_t5()) {
    _this->_impl_.t5_ = new ::Thrusters_Pos(*from._impl_.t5_);
  }
  if (from._internal_has_t6()) {
    _this->_impl_.t6_ = new ::Thrusters_Pos(*from._impl_.t6_);
  }
  if (from._internal_has_t7()) {
    _this->_impl_.t7_ = new ::Thrusters_Pos(*from._impl_.t7_);
  }
  if (from._internal_has_t8()) {
    _this->_impl_.t8_ = new ::Thrusters_Pos(*from._impl_.t8_);
  }
  ::memcpy(&_impl_.maxpowt1_, &from._impl_.maxpowt1_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.maxpowt8_) -
    reinterpret_cast<char*>(&_impl_.maxpowt1_)) + sizeof(_impl_.maxpowt8_));
  // @@protoc_insertion_point(copy_constructor:Thrusters)
}

inline void Thrusters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.t1_){nullptr}
    , decltype(_impl_.t2_){nullptr}
    , decltype(_impl_.t3_){nullptr}
    , decltype(_impl_.t4_){nullptr}
    , decltype(_impl_.t5_){nullptr}
    , decltype(_impl_.t6_){nullptr}
    , decltype(_impl_.t7_){nullptr}
    , decltype(_impl_.t8_){nullptr}
    , decltype(_impl_.maxpowt1_){0}
    , decltype(_impl_.maxpowt2_){0}
    , decltype(_impl_.maxpowt3_){0}
    , decltype(_impl_.maxpowt4_){0}
    , decltype(_impl_.maxpowt5_){0}
    , decltype(_impl_.maxpowt6_){0}
    , decltype(_impl_.maxpowt7_){0}
    , decltype(_impl_.maxpowt8_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Thrusters::~Thrusters() {
  // @@protoc_insertion_point(destructor:Thrusters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Thrusters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.t1_;
  if (this != internal_default_instance()) delete _impl_.t2_;
  if (this != internal_default_instance()) delete _impl_.t3_;
  if (this != internal_default_instance()) delete _impl_.t4_;
  if (this != internal_default_instance()) delete _impl_.t5_;
  if (this != internal_default_instance()) delete _impl_.t6_;
  if (this != internal_default_instance()) delete _impl_.t7_;
  if (this != internal_default_instance()) delete _impl_.t8_;
}

void Thrusters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Thrusters::Clear() {
// @@protoc_insertion_point(message_clear_start:Thrusters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.t1_ != nullptr) {
    delete _impl_.t1_;
  }
  _impl_.t1_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.t2_ != nullptr) {
    delete _impl_.t2_;
  }
  _impl_.t2_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.t3_ != nullptr) {
    delete _impl_.t3_;
  }
  _impl_.t3_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.t4_ != nullptr) {
    delete _impl_.t4_;
  }
  _impl_.t4_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.t5_ != nullptr) {
    delete _impl_.t5_;
  }
  _impl_.t5_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.t6_ != nullptr) {
    delete _impl_.t6_;
  }
  _impl_.t6_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.t7_ != nullptr) {
    delete _impl_.t7_;
  }
  _impl_.t7_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.t8_ != nullptr) {
    delete _impl_.t8_;
  }
  _impl_.t8_ = nullptr;
  ::memset(&_impl_.maxpowt1_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.maxpowt8_) -
      reinterpret_cast<char*>(&_impl_.maxpowt1_)) + sizeof(_impl_.maxpowt8_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Thrusters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Thrusters.Pos T1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_t1(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Thrusters.Pos T2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_t2(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Thrusters.Pos T3 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_t3(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Thrusters.Pos T4 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_t4(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Thrusters.Pos T5 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_t5(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Thrusters.Pos T6 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_t6(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Thrusters.Pos T7 = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_t7(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Thrusters.Pos T8 = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_t8(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float MaxPowT1 = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _impl_.maxpowt1_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float MaxPowT2 = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _impl_.maxpowt2_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float MaxPowT3 = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _impl_.maxpowt3_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float MaxPowT4 = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _impl_.maxpowt4_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float MaxPowT5 = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _impl_.maxpowt5_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float MaxPowT6 = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          _impl_.maxpowt6_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float MaxPowT7 = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          _impl_.maxpowt7_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float MaxPowT8 = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 133)) {
          _impl_.maxpowt8_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Thrusters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Thrusters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Thrusters.Pos T1 = 1;
  if (this->_internal_has_t1()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::t1(this),
        _Internal::t1(this).GetCachedSize(), target, stream);
  }

  // .Thrusters.Pos T2 = 2;
  if (this->_internal_has_t2()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::t2(this),
        _Internal::t2(this).GetCachedSize(), target, stream);
  }

  // .Thrusters.Pos T3 = 3;
  if (this->_internal_has_t3()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::t3(this),
        _Internal::t3(this).GetCachedSize(), target, stream);
  }

  // .Thrusters.Pos T4 = 4;
  if (this->_internal_has_t4()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::t4(this),
        _Internal::t4(this).GetCachedSize(), target, stream);
  }

  // .Thrusters.Pos T5 = 5;
  if (this->_internal_has_t5()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::t5(this),
        _Internal::t5(this).GetCachedSize(), target, stream);
  }

  // .Thrusters.Pos T6 = 6;
  if (this->_internal_has_t6()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::t6(this),
        _Internal::t6(this).GetCachedSize(), target, stream);
  }

  // .Thrusters.Pos T7 = 7;
  if (this->_internal_has_t7()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::t7(this),
        _Internal::t7(this).GetCachedSize(), target, stream);
  }

  // .Thrusters.Pos T8 = 8;
  if (this->_internal_has_t8()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::t8(this),
        _Internal::t8(this).GetCachedSize(), target, stream);
  }

  // float MaxPowT1 = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxpowt1 = this->_internal_maxpowt1();
  uint32_t raw_maxpowt1;
  memcpy(&raw_maxpowt1, &tmp_maxpowt1, sizeof(tmp_maxpowt1));
  if (raw_maxpowt1 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_maxpowt1(), target);
  }

  // float MaxPowT2 = 10;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxpowt2 = this->_internal_maxpowt2();
  uint32_t raw_maxpowt2;
  memcpy(&raw_maxpowt2, &tmp_maxpowt2, sizeof(tmp_maxpowt2));
  if (raw_maxpowt2 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_maxpowt2(), target);
  }

  // float MaxPowT3 = 11;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxpowt3 = this->_internal_maxpowt3();
  uint32_t raw_maxpowt3;
  memcpy(&raw_maxpowt3, &tmp_maxpowt3, sizeof(tmp_maxpowt3));
  if (raw_maxpowt3 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_maxpowt3(), target);
  }

  // float MaxPowT4 = 12;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxpowt4 = this->_internal_maxpowt4();
  uint32_t raw_maxpowt4;
  memcpy(&raw_maxpowt4, &tmp_maxpowt4, sizeof(tmp_maxpowt4));
  if (raw_maxpowt4 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(12, this->_internal_maxpowt4(), target);
  }

  // float MaxPowT5 = 13;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxpowt5 = this->_internal_maxpowt5();
  uint32_t raw_maxpowt5;
  memcpy(&raw_maxpowt5, &tmp_maxpowt5, sizeof(tmp_maxpowt5));
  if (raw_maxpowt5 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(13, this->_internal_maxpowt5(), target);
  }

  // float MaxPowT6 = 14;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxpowt6 = this->_internal_maxpowt6();
  uint32_t raw_maxpowt6;
  memcpy(&raw_maxpowt6, &tmp_maxpowt6, sizeof(tmp_maxpowt6));
  if (raw_maxpowt6 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(14, this->_internal_maxpowt6(), target);
  }

  // float MaxPowT7 = 15;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxpowt7 = this->_internal_maxpowt7();
  uint32_t raw_maxpowt7;
  memcpy(&raw_maxpowt7, &tmp_maxpowt7, sizeof(tmp_maxpowt7));
  if (raw_maxpowt7 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(15, this->_internal_maxpowt7(), target);
  }

  // float MaxPowT8 = 16;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxpowt8 = this->_internal_maxpowt8();
  uint32_t raw_maxpowt8;
  memcpy(&raw_maxpowt8, &tmp_maxpowt8, sizeof(tmp_maxpowt8));
  if (raw_maxpowt8 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(16, this->_internal_maxpowt8(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Thrusters)
  return target;
}

size_t Thrusters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Thrusters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Thrusters.Pos T1 = 1;
  if (this->_internal_has_t1()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.t1_);
  }

  // .Thrusters.Pos T2 = 2;
  if (this->_internal_has_t2()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.t2_);
  }

  // .Thrusters.Pos T3 = 3;
  if (this->_internal_has_t3()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.t3_);
  }

  // .Thrusters.Pos T4 = 4;
  if (this->_internal_has_t4()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.t4_);
  }

  // .Thrusters.Pos T5 = 5;
  if (this->_internal_has_t5()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.t5_);
  }

  // .Thrusters.Pos T6 = 6;
  if (this->_internal_has_t6()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.t6_);
  }

  // .Thrusters.Pos T7 = 7;
  if (this->_internal_has_t7()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.t7_);
  }

  // .Thrusters.Pos T8 = 8;
  if (this->_internal_has_t8()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.t8_);
  }

  // float MaxPowT1 = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxpowt1 = this->_internal_maxpowt1();
  uint32_t raw_maxpowt1;
  memcpy(&raw_maxpowt1, &tmp_maxpowt1, sizeof(tmp_maxpowt1));
  if (raw_maxpowt1 != 0) {
    total_size += 1 + 4;
  }

  // float MaxPowT2 = 10;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxpowt2 = this->_internal_maxpowt2();
  uint32_t raw_maxpowt2;
  memcpy(&raw_maxpowt2, &tmp_maxpowt2, sizeof(tmp_maxpowt2));
  if (raw_maxpowt2 != 0) {
    total_size += 1 + 4;
  }

  // float MaxPowT3 = 11;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxpowt3 = this->_internal_maxpowt3();
  uint32_t raw_maxpowt3;
  memcpy(&raw_maxpowt3, &tmp_maxpowt3, sizeof(tmp_maxpowt3));
  if (raw_maxpowt3 != 0) {
    total_size += 1 + 4;
  }

  // float MaxPowT4 = 12;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxpowt4 = this->_internal_maxpowt4();
  uint32_t raw_maxpowt4;
  memcpy(&raw_maxpowt4, &tmp_maxpowt4, sizeof(tmp_maxpowt4));
  if (raw_maxpowt4 != 0) {
    total_size += 1 + 4;
  }

  // float MaxPowT5 = 13;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxpowt5 = this->_internal_maxpowt5();
  uint32_t raw_maxpowt5;
  memcpy(&raw_maxpowt5, &tmp_maxpowt5, sizeof(tmp_maxpowt5));
  if (raw_maxpowt5 != 0) {
    total_size += 1 + 4;
  }

  // float MaxPowT6 = 14;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxpowt6 = this->_internal_maxpowt6();
  uint32_t raw_maxpowt6;
  memcpy(&raw_maxpowt6, &tmp_maxpowt6, sizeof(tmp_maxpowt6));
  if (raw_maxpowt6 != 0) {
    total_size += 1 + 4;
  }

  // float MaxPowT7 = 15;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxpowt7 = this->_internal_maxpowt7();
  uint32_t raw_maxpowt7;
  memcpy(&raw_maxpowt7, &tmp_maxpowt7, sizeof(tmp_maxpowt7));
  if (raw_maxpowt7 != 0) {
    total_size += 1 + 4;
  }

  // float MaxPowT8 = 16;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxpowt8 = this->_internal_maxpowt8();
  uint32_t raw_maxpowt8;
  memcpy(&raw_maxpowt8, &tmp_maxpowt8, sizeof(tmp_maxpowt8));
  if (raw_maxpowt8 != 0) {
    total_size += 2 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Thrusters::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Thrusters::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Thrusters::GetClassData() const { return &_class_data_; }


void Thrusters::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Thrusters*>(&to_msg);
  auto& from = static_cast<const Thrusters&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Thrusters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_t1()) {
    _this->_internal_mutable_t1()->::Thrusters_Pos::MergeFrom(
        from._internal_t1());
  }
  if (from._internal_has_t2()) {
    _this->_internal_mutable_t2()->::Thrusters_Pos::MergeFrom(
        from._internal_t2());
  }
  if (from._internal_has_t3()) {
    _this->_internal_mutable_t3()->::Thrusters_Pos::MergeFrom(
        from._internal_t3());
  }
  if (from._internal_has_t4()) {
    _this->_internal_mutable_t4()->::Thrusters_Pos::MergeFrom(
        from._internal_t4());
  }
  if (from._internal_has_t5()) {
    _this->_internal_mutable_t5()->::Thrusters_Pos::MergeFrom(
        from._internal_t5());
  }
  if (from._internal_has_t6()) {
    _this->_internal_mutable_t6()->::Thrusters_Pos::MergeFrom(
        from._internal_t6());
  }
  if (from._internal_has_t7()) {
    _this->_internal_mutable_t7()->::Thrusters_Pos::MergeFrom(
        from._internal_t7());
  }
  if (from._internal_has_t8()) {
    _this->_internal_mutable_t8()->::Thrusters_Pos::MergeFrom(
        from._internal_t8());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxpowt1 = from._internal_maxpowt1();
  uint32_t raw_maxpowt1;
  memcpy(&raw_maxpowt1, &tmp_maxpowt1, sizeof(tmp_maxpowt1));
  if (raw_maxpowt1 != 0) {
    _this->_internal_set_maxpowt1(from._internal_maxpowt1());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxpowt2 = from._internal_maxpowt2();
  uint32_t raw_maxpowt2;
  memcpy(&raw_maxpowt2, &tmp_maxpowt2, sizeof(tmp_maxpowt2));
  if (raw_maxpowt2 != 0) {
    _this->_internal_set_maxpowt2(from._internal_maxpowt2());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxpowt3 = from._internal_maxpowt3();
  uint32_t raw_maxpowt3;
  memcpy(&raw_maxpowt3, &tmp_maxpowt3, sizeof(tmp_maxpowt3));
  if (raw_maxpowt3 != 0) {
    _this->_internal_set_maxpowt3(from._internal_maxpowt3());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxpowt4 = from._internal_maxpowt4();
  uint32_t raw_maxpowt4;
  memcpy(&raw_maxpowt4, &tmp_maxpowt4, sizeof(tmp_maxpowt4));
  if (raw_maxpowt4 != 0) {
    _this->_internal_set_maxpowt4(from._internal_maxpowt4());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxpowt5 = from._internal_maxpowt5();
  uint32_t raw_maxpowt5;
  memcpy(&raw_maxpowt5, &tmp_maxpowt5, sizeof(tmp_maxpowt5));
  if (raw_maxpowt5 != 0) {
    _this->_internal_set_maxpowt5(from._internal_maxpowt5());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxpowt6 = from._internal_maxpowt6();
  uint32_t raw_maxpowt6;
  memcpy(&raw_maxpowt6, &tmp_maxpowt6, sizeof(tmp_maxpowt6));
  if (raw_maxpowt6 != 0) {
    _this->_internal_set_maxpowt6(from._internal_maxpowt6());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxpowt7 = from._internal_maxpowt7();
  uint32_t raw_maxpowt7;
  memcpy(&raw_maxpowt7, &tmp_maxpowt7, sizeof(tmp_maxpowt7));
  if (raw_maxpowt7 != 0) {
    _this->_internal_set_maxpowt7(from._internal_maxpowt7());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_maxpowt8 = from._internal_maxpowt8();
  uint32_t raw_maxpowt8;
  memcpy(&raw_maxpowt8, &tmp_maxpowt8, sizeof(tmp_maxpowt8));
  if (raw_maxpowt8 != 0) {
    _this->_internal_set_maxpowt8(from._internal_maxpowt8());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Thrusters::CopyFrom(const Thrusters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Thrusters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Thrusters::IsInitialized() const {
  return true;
}

void Thrusters::InternalSwap(Thrusters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Thrusters, _impl_.maxpowt8_)
      + sizeof(Thrusters::_impl_.maxpowt8_)
      - PROTOBUF_FIELD_OFFSET(Thrusters, _impl_.t1_)>(
          reinterpret_cast<char*>(&_impl_.t1_),
          reinterpret_cast<char*>(&other->_impl_.t1_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Thrusters::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_moto_5fproto_2eproto_getter, &descriptor_table_moto_5fproto_2eproto_once,
      file_level_metadata_moto_5fproto_2eproto[2]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::ControllerInput*
Arena::CreateMaybeMessage< ::ControllerInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ControllerInput >(arena);
}
template<> PROTOBUF_NOINLINE ::Thrusters_Pos*
Arena::CreateMaybeMessage< ::Thrusters_Pos >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Thrusters_Pos >(arena);
}
template<> PROTOBUF_NOINLINE ::Thrusters*
Arena::CreateMaybeMessage< ::Thrusters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Thrusters >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
